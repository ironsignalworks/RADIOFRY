<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>RADIOFRY — Fry your audio. Export a WAV.</title>
   
  <!-- Favicon -->
  <link rel="icon" href="favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="isw.png">
  <link rel="apple-touch-icon" href="isw.png">
  
  <!-- Canonical + SEO -->
  <link rel="canonical" href="https://ironsignalworks.com/radiofry" />
  <meta name="description" content="RADIOFRY — browser-based audio degrader & field-recording tool. Distortion, echo, crush, glitch, reverb, reverse, mic record, and baked WAV export — all local." />

  <!-- Open Graph / Twitter cards -->
  <meta property="og:title" content="RADIOFRY — Fry your audio. Export a WAV." />
  <meta property="og:description" content="Degrade, distort, and export: distortion, echo, crush, glitch, reverb, reverse, mic record, and baked WAV export — all local." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://ironsignalworks.com/radiofry" />
  <meta property="og:image" content="isw2_logo.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="RADIOFRY — Fry your audio. Export a WAV." />
  <meta name="twitter:description" content="Degrade, distort, and export — all in the browser, no tracking." />
  <meta name="twitter:image" content="isw2_logo.png" />

  <!-- WebApplication Schema (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"WebApplication",
    "name":"RADIOFRY",
    "url":"https://ironsignalworks.com/radiofry",
    "applicationCategory":"MultimediaApplication",
    "operatingSystem":"Any",
    "description":"Browser-based audio degrader and field-recording tool with WAV export.",
    "creator":{"@type":"Organization","name":"Iron Signal Works"}
  }
  </script>

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="favicon.ico" />

  <style>
    :root{
      /* Retro 95 (default) */
      --win-gray:#c0c0c0; --win-dark:#808080; --win-darker:#404040; --win-light:#dfdfdf; --win-white:#ffffff; --win-blue:#000080; --ink:#000000;
      --accent:#00ff66;
      --gap:8px; --btn-h:40px;
      --border-focus:#22c55e;
    }
    *{box-sizing:border-box}

    body{
      margin:0; font-family:Tahoma,Verdana,"MS Sans Serif",system-ui,sans-serif;
      background:#2f7f81; color:var(--ink);
      min-height:100dvh; display:flex; align-items:flex-start; justify-content:center;
      padding-top:8px; overflow:hidden;
    }

    /* Base canvas (desktop scales to fit) */
    .app{
      position:relative;
      width:1280px;   /* base width */
      height:760px;   /* base height */
      background:var(--win-gray);
      display:grid; grid-template-rows:auto 1fr auto;
      overflow:hidden;
      transform-origin:top center;
    }
    .bevel{border:2px solid var(--win-dark); border-right-color:var(--win-white); border-bottom-color:var(--win-white)}
    .bevel-out{border:2px solid var(--win-white); border-right-color:var(--win-darker); border-bottom-color:var(--win-darker)}
    .pane{background:var(--win-light)}

    /* Title bar */
    header.titlebar{display:flex; align-items:center; justify-content:space-between; background:var(--win-blue); color:#fff; padding:4px 6px}
    .brand{display:flex; align-items:center; gap:8px}
    .brand a{display:flex; align-items:center; gap:8px; color:#b8ffcc; text-decoration:none}
    .brand a:focus{outline:2px solid var(--border-focus); outline-offset:2px; border-radius:4px}
    .brand .title{font-weight:700; letter-spacing:.4px}
    .window-controls{display:flex; gap:6px; align-items:center}

    main{display:grid; grid-template-columns:320px 1fr; gap:var(--gap); padding:var(--gap); min-height:0}

    /* Left panel */
    .panel{background:var(--win-light); overflow:visible; color:var(--ink)}
    .group{padding:var(--gap); display:flex; flex-direction:column; gap:var(--gap)}
    .label{font-size:.9rem}

    .btn{
      appearance:none; font:inherit; color:var(--ink); background:var(--win-gray);
      padding:6px 8px; cursor:pointer; border:none; height:var(--btn-h);
      display:inline-flex; align-items:center; justify-content:center; min-width:0; text-align:center;
    }
    .btn.bevel-out{border:2px solid var(--win-white); border-right-color:var(--win-darker); border-bottom-color:var(--win-darker)}
    .btn[data-active="true"]{background:#ffe28a}
    .btn:focus{outline:2px solid var(--border-focus); outline-offset:2px}

    #presets{display:grid; grid-template-columns:repeat(3,1fr); gap:var(--gap)}
    #presets .btn{width:100%}
    #reset{width:100%}

    .grid-2{display:grid; grid-template-columns:repeat(2,1fr); gap:6px}
    .grid-2 .btn{width:100%}

    .slider{display:grid; grid-template-columns:120px 1fr 60px; gap:var(--gap); align-items:center}
    .slider input[type=range]{width:100%; height:24px; background:transparent; -webkit-appearance:none; appearance:none}
    .slider input[type=range]::-webkit-slider-runnable-track{height:8px; background:var(--win-dark)}
    .slider input[type=range]::-moz-range-track{height:8px; background:var(--win-dark)}
    .slider input[type=range]::-webkit-slider-thumb{-webkit-appearance:none; width:16px; height:18px; background:var(--win-gray); border:2px solid var(--win-darker); margin-top:-5px}
    .slider input[type=range]::-moz-range-thumb{width:16px; height:18px; background:var(--win-gray); border:2px solid var(--win-darker)}
    .slider output{text-align:right}
    .slider select{width:100%; min-width:0}
    .slider select.btn{padding:2px 6px}

    /* Right stage */
    .stage{display:grid; grid-template-rows:auto minmax(240px,1fr) auto; gap:var(--gap); min-height:0}
    .topbar{background:var(--win-light); padding:6px; color:var(--ink)}
    .topbar .controls{display:flex; align-items:center; gap:6px; flex-wrap:wrap}
    input[type=file]{display:none}
    .filebtn{display:inline-flex; align-items:center; justify-content:center}
    .filename{font-size:.9rem; opacity:.9}

    canvas#visualizer{width:100%; height:100%; background:#000; image-rendering:pixelated; display:block}

    .player{display:flex; align-items:center; gap:6px; background:var(--win-light); padding:6px 8px; min-height:52px; color:var(--ink)}
    .btn.sq{width:var(--btn-h); height:var(--btn-h); font-weight:700}
    #seek{flex:1; position:relative; top:-1px}
    .time{min-width:5ch; text-align:center}
    #seek::-webkit-slider-runnable-track{height:10px; background:var(--win-dark)}
    #seek::-moz-range-track{height:10px; background:var(--win-dark)}
    #seek::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:18px;background:var(--win-gray);border:2px solid var(--win-darker);margin-top:-4px}
    #seek::-moz-range-thumb{width:14px;height:18px;background:var(--win-gray);border:2px solid var(--win-darker)}

    footer{color:var(--ink)}

    /* Help popup */
    .howto{position:absolute; top:44px; right:12px; width:min(380px, 92vw); background:var(--win-light); padding:8px; z-index:50; display:none; color:var(--ink)}
    .howto.show{display:block}
    .howto header{display:flex; align-items:center; justify-content:space-between; font-weight:700; margin-bottom:6px}
    .howto .body{font-size:.95rem; line-height:1.35}
    .howto .body li{margin:6px 0}
    .lede{margin:0 0 6px 0; opacity:.95}
    .howto:focus{outline:2px solid var(--border-focus); outline-offset:2px}

    /* ------- SKINS ------- */

    /* Dark-Ops (matte, covert) */
    .skin-darkops{
      --win-gray:#1d211d;
      --win-light:#161a16;
      --win-dark:#0e120e;
      --win-darker:#000000;
      --win-white:#3d443d;
      --win-blue:#0f2710;
      --ink:#ffffff;
      --accent:#8fd27a;
    }
    .skin-darkops .titlebar,
    .skin-darkops .panel,
    .skin-darkops .topbar,
    .skin-darkops .player,
    .skin-darkops footer,
    .skin-darkops .howto{ color:var(--ink); }
    .skin-darkops .btn{background:#1b201b; color:var(--ink); border-color:#333}
    .skin-darkops select{background:#1b201b; color:var(--ink); border-color:#333}
    .skin-darkops .label,
    .skin-darkops .slider span,
    .skin-darkops .slider output,
    .skin-darkops .filename,
    .skin-darkops .time{ color:#ffffff; }

    /* Office Glow */
    .skin-office{
      --win-gray:#dfe3ee; --win-light:#f6f7fb; --win-dark:#cfd5e4; --win-darker:#9094a8;
      --win-white:#ffffff; --win-blue:#1f3aa2; --ink:#111;
    }
    .skin-office .bevel{border-radius:8px; box-shadow:inset 0 1px 0 #fff, inset 0 -1px 0 #cfd5e4, 0 10px 24px rgba(0,0,0,.18)}
    .skin-office .bevel-out{border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,.18)}
    .skin-office .btn{border-radius:6px}

    /* Accessibility / reduced motion */
    @media (prefers-reduced-motion: reduce){
      *{animation:none!important; transition:none!important}
    }

    /* Mobile: allow scroll, no scaling */
    @media (max-width:900px){
      :root{ --btn-h:36px }
      body{align-items:stretch; justify-content:stretch; padding-top:8px; overflow:auto}
      .app{width:100%; height:auto; transform:none}
      main{grid-template-columns:1fr}
      .stage{grid-template-rows:auto minmax(180px, 45dvh) auto}
      .btn{font-size:.95rem}
    }
  </style>
</head>
<body>
  <div class="app bevel" id="app" role="application" aria-label="RADIOFRY interface">
    <header class="titlebar">
      <div class="brand">
        <a href="https://ironsignalworks.com" target="_blank" rel="noopener" aria-label="Visit Iron Signal Works">
          <!-- Tiny radio avatar -->
          <svg class="avatar" width="22" height="16" viewBox="0 0 22 16" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M2 6h18v7H2zM4 5l12-4M5 10h6M6 8h8M16 9v3M4 9v3" stroke="var(--accent)" stroke-width="2"/>
          </svg>
          <div class="title">RADIOFRY</div>
        </a>
      </div>
      <div class="window-controls">
        <button id="shareBtn" class="btn bevel-out" aria-label="Share this setup">Share</button>
        <button id="skinBtn" class="btn bevel-out" aria-label="Change UI skin">Skin: Retro 95</button>
        <button id="helpBtn" class="btn bevel-out" aria-haspopup="dialog" aria-controls="howto">How to Fry</button>
      </div>
    </header>

    <main>
      <!-- Left: controls -->
      <aside class="panel bevel" aria-label="Controls">
        <div class="group">
          <div class="label" id="presetsLabel">Presets</div>
          <div id="presets" role="group" aria-labelledby="presetsLabel">
            <button class="btn bevel-out" data-preset="CHARRED">CHARRED</button>
            <button class="btn bevel-out" data-preset="BAKED">BAKED</button>
            <button class="btn bevel-out" data-preset="FRIED">FRIED</button>
          </div>
          <button class="btn bevel-out" id="reset">Reset</button>
        </div>

        <div class="group">
          <div class="label" id="effectsLabel">Effects</div>
          <div class="grid-2" id="effects" role="group" aria-labelledby="effectsLabel">
            <button class="btn bevel-out" data-effect="distortion" aria-pressed="false">Distortion</button>
            <button class="btn bevel-out" data-effect="echo" aria-pressed="false">Echo</button>
            <button class="btn bevel-out" data-effect="crush" aria-pressed="false">Crush</button>
            <button class="btn bevel-out" data-effect="glitch" aria-pressed="false">Glitch</button>
          </div>

          <label class="slider"><span id="revLabel">Reverb Preset</span>
            <select id="reverbPreset" class="btn bevel-out" aria-labelledby="revLabel" style="height:26px">
              <option value="off">Off</option>
              <option value="small-room">Small Room</option>
              <option value="cathedral">Cathedral Room</option>
              <option value="fort-tunnel">Fort Worden Tunnel</option>
              <option value="drainage">Drainage Tunnel</option>
              <option value="discovery">Discovery Room</option>
              <option value="tunnel-heaven">Tunnel To Heaven</option>
            </select>
          </label>
        </div>

        <div class="group">
          <label class="slider"><span id="freqLabel">Filter Freq</span>
            <input id="freq" type="range" min="200" max="4000" step="10" value="1200" aria-labelledby="freqLabel"/>
            <output id="freqOut" aria-live="polite">1200Hz</output></label>

          <label class="slider"><span id="pitchLabel">Pitch (Speed)</span>
            <input id="pitch" type="range" min="0.5" max="1.5" step="0.01" value="1" aria-labelledby="pitchLabel"/>
            <output id="pitchOut" aria-live="polite">1.00×</output></label>

          <label class="slider"><span id="volLabel">Volume</span>
            <input id="vol" type="range" min="0" max="2" step="0.01" value="1" aria-labelledby="volLabel"/>
            <output id="volOut" aria-live="polite">1.00</output></label>

          <!-- Full-width stacked buttons -->
          <button id="reverse" class="btn bevel-out" style="width:100%" aria-pressed="false">↺ Reverse</button>
          <button id="record"  class="btn bevel-out" style="width:100%">● Rec</button>
          <button id="micBtn"  class="btn bevel-out" style="width:100%" aria-pressed="false">🎙️ Use Mic</button>
          <button id="export"  class="btn bevel-out" style="width:100%">Export WAV</button>
        </div>
      </aside>

      <!-- Right: stage -->
      <section class="stage" aria-label="Stage">
        <div class="topbar bevel">
          <div class="controls">
            <input type="file" id="file" accept="audio/*" aria-label="Choose audio file"/>
            <label for="file" class="btn bevel-out filebtn" id="fileBtn">📁 Choose File</label>
            <span class="filename" id="fileName" aria-live="polite">No file chosen</span>
          </div>
        </div>

        <canvas id="visualizer" class="bevel" role="img" aria-label="Audio waveform"></canvas>

        <div class="player bevel" aria-label="Transport">
          <button id="play" class="btn sq bevel-out" aria-label="Play/Pause">▶</button>
          <span id="curT" class="time" aria-live="polite">0:00</span>
          <input id="seek" type="range" min="0" max="1000" value="0" aria-label="Seek"/>
          <span id="durT" class="time" aria-live="polite">0:00</span>
        </div>

        <audio id="player" preload="metadata" hidden></audio>
      </section>
    </main>

    <footer class="pane bevel" aria-label="Footer">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;padding:6px 8px;">
        <span>No tracking. Local only.</span>
        <span>
			 Built by
          <a href="https://ironsignalworks.com" target="_blank" rel="noopener">Iron Signal Works</a> —
          <a href="https://ironsignalworks.com#hire" target="_blank" rel="noopener" aria-label="Hire Iron Signal Works">Hire us →</a>
        </span>
      </div>
    </footer>

    <!-- Popup: How to Fry -->
    <div id="howto" class="howto bevel" role="dialog" aria-modal="true" aria-labelledby="howtoTitle">
      <header>
        <span id="howtoTitle">How to Fry — Quick Guide</span>
        <button id="howtoClose" class="btn bevel-out" aria-label="Close help">✕</button>
      </header>
      <div class="body">
        <p class="lede"><b>RADIOFRY</b> is a browser-based <b>audio degrader</b> and <b>field-recording tool</b>. Drop a file or capture from your mic, mangle with lo-fi effects, then export a baked WAV — all local, no tracking.</p>
        <ol>
          <li><b>Load sound</b>: Click <b>📁 Choose File</b> or toggle <b>🎙️ Use Mic</b>.</li>
          <li><b>Preview</b>: Press <b>▶</b> and scrub the seek bar to navigate.</li>
          <li><b>Flavor</b>: Toggle <b>Distortion</b>, <b>Echo</b>, <b>Crush</b>, <b>Glitch</b>. Pick a <b>Reverb Preset</b>.</li>
          <li><b>Shape</b>: Adjust <b>Filter Freq</b>, <b>Pitch (Speed)</b>, and <b>Volume</b>.</li>
          <li><b>Reverse</b>: Flip your audio backwards for instant tape-style effects.</li>
          <li><b>● Rec</b>: Record exactly what you hear (post-FX) to a WEBM.</li>
          <li><b>Export WAV</b>: Bakes the full chain offline and downloads a WAV with an Iron Signal Works signature in metadata.</li>
          <li><b>Share</b>: Copies a URL that reloads your setup — with UTM tags for analytics.</li>
        </ol>
      </div>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      /* ---------- Fit-to-viewport scaling (desktop) ---------- */
      const appEl = document.getElementById('app');
      const BASE_W = 1280, BASE_H = 760, MARGIN = 16;
      function fitToViewport(){
        if (window.matchMedia('(max-width:900px)').matches){
          appEl.style.transform = 'none';
          appEl.style.width = '100%';
          appEl.style.height = 'auto';
          document.body.style.overflow = 'auto';
          return;
        }
        appEl.style.width = BASE_W + 'px';
        appEl.style.height = BASE_H + 'px';
        const sw = (window.innerWidth  - MARGIN) / BASE_W;
        const sh = (window.innerHeight - MARGIN) / BASE_H;
        const scale = Math.min(1, sw, sh) * 0.98;
        appEl.style.transform = `scale(${scale})`;
        document.body.style.overflow = 'hidden';
      }
      window.addEventListener('resize', fitToViewport, {passive:true});
      fitToViewport();

      /* ---------- UI refs ---------- */
      const skinBtn = document.getElementById('skinBtn');
      const helpBtn = document.getElementById('helpBtn');
      const howto = document.getElementById('howto');
      const howtoClose = document.getElementById('howtoClose');

      const file = document.getElementById('file');
      const fileName = document.getElementById('fileName');
      const player = document.getElementById('player');
      const recordBtn = document.getElementById('record');
      const reverseBtn = document.getElementById('reverse');
      const micBtn = document.getElementById('micBtn');
      const presetsRow = document.getElementById('presets');
      const reverbPresetSel = document.getElementById('reverbPreset');
      const effWrap = document.getElementById('effects');
      const freq = document.getElementById('freq');
      const freqOut = document.getElementById('freqOut');
      const vol = document.getElementById('vol');
      const volOut = document.getElementById('volOut');
      const pitch = document.getElementById('pitch');
      const pitchOut = document.getElementById('pitchOut');
      const exportBtn = document.getElementById('export');
      const canvas = document.getElementById('visualizer');
      const ctx = canvas.getContext('2d');
      const playBtn = document.getElementById('play');
      const seek = document.getElementById('seek');
      const curT = document.getElementById('curT');
      const durT = document.getElementById('durT');
      const resetBtn = document.getElementById('reset');
      const shareBtn = document.getElementById('shareBtn');

      /* ---------- Skins ---------- */
      const skins = ['classic','darkops','office'];
      let skinIndex = 0;
      function applySkin(k){
        appEl.classList.remove('skin-darkops','skin-office');
        if(k==='darkops') appEl.classList.add('skin-darkops');
        if(k==='office')  appEl.classList.add('skin-office');
        skinBtn.textContent = 'Skin: ' + (
          k==='classic' ? 'Retro 95' :
          k==='darkops' ? 'Dark-Ops' :
          'Office Glow'
        );
      }
      skinBtn.addEventListener('click', ()=>{ skinIndex=(skinIndex+1)%skins.length; applySkin(skins[skinIndex]); });
      applySkin('classic');

      /* ---------- Audio graph state ---------- */
      let audioCtx; let analyser; let source; let gain; let filter; let playerSource=null;
      let nodes = {};
      let originalBuffer=null; let originalURL=null; let reversedURL=null; let reversed=false;
      let recorder=null; let recordChunks=[];
      let micStream=null; let micSource=null; let loadedIRBuffer=null; let reverbWet=0.35;
      const effect = { distortion:false, echo:false, crush:false, glitch:false, reverb:false };
      let glitchTimer=null;

      function setCanvasSize(){
        const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1));
        const rect=canvas.getBoundingClientRect();
        let w=Math.floor(rect.width), h=Math.floor(rect.height);
        if(w<=0 || h<=0){ const p=canvas.parentElement; w=(p&&p.clientWidth)||640; h=(p&&p.clientHeight)||240; }
        canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr);
      }
      const fmt = n=>{ const t=Math.floor(n||0); const m=Math.floor(t/60); const s=String(t%60).padStart(2,'0'); return `${m}:${s}`; };
      const dec2 = n=>Number(n).toFixed(2);

      function ensureContext(){
        if(!audioCtx){
          audioCtx=new (window.AudioContext||window.webkitAudioContext)();
          analyser=audioCtx.createAnalyser(); analyser.fftSize=2048;
          gain=audioCtx.createGain();
          filter=audioCtx.createBiquadFilter(); filter.type='bandpass'; filter.frequency.value=+freq.value;

          nodes.distortion=audioCtx.createWaveShaper();
          nodes.post=audioCtx.createBiquadFilter(); nodes.post.type='bandpass'; nodes.post.frequency.value=1000; nodes.post.Q.value=1.5;
          nodes.distGain=audioCtx.createGain(); nodes.distGain.gain.value=.4;

          nodes.delay=audioCtx.createDelay(); nodes.delay.delayTime.value=.25;
          nodes.feedback=audioCtx.createGain(); nodes.feedback.gain.value=.3; nodes.delay.connect(nodes.feedback); nodes.feedback.connect(nodes.delay);

          nodes.bit=audioCtx.createBiquadFilter(); nodes.bit.type='highshelf'; nodes.bit.frequency.value=8000; nodes.bit.gain.value=0;
          nodes.glitch=audioCtx.createGain(); nodes.glitch.gain.value=1;

          nodes.convolver = audioCtx.createConvolver();
          nodes.gainWet  = audioCtx.createGain(); nodes.gainWet.gain.value  = reverbWet;
          nodes.gainDry  = audioCtx.createGain(); nodes.gainDry.gain.value  = 1 - reverbWet;

          nodes.streamDest = audioCtx.createMediaStreamDestination();
        }
        if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
      }

      function makeCurve(amount=75){ const n=44100; const c=new Float32Array(n); for(let i=0;i<n;i++){ const x=i*2/n-1; c[i]=Math.tanh((amount+1)*x)/Math.tanh(amount+1); } return c; }
      function toggleGlitch(on){ if(!nodes.glitch) return; nodes.glitch.gain.value=1; if(glitchTimer){ clearInterval(glitchTimer); glitchTimer=null; } if(on){ glitchTimer=setInterval(()=>{ nodes.glitch.gain.value=Math.random()>.5?1:0; },30); } }

      const IR_MAP = {
        'small-room':'reverbs/small-room.wav',
        'cathedral':'reverbs/CathedralRoom.wav',
        'fort-tunnel':'reverbs/FortWordenTunnel.wav',
        'drainage':'reverbs/DrainageTunnel.wav',
        'discovery':'reverbs/DiscoveryRoom.wav',
        'tunnel-heaven':'reverbs/TunnelToHeaven.wav'
      };
      function loadIR(key){
        if(!key || key==='off'){ loadedIRBuffer=null; return Promise.resolve(); }
        const url = IR_MAP[key]; if(!url){ loadedIRBuffer=null; return Promise.resolve(); }
        ensureContext();
        return fetch(url).then(r=>r.arrayBuffer()).then(ab=>audioCtx.decodeAudioData(ab))
          .then(buf=>{ loadedIRBuffer=buf; nodes.convolver.buffer=buf; })
          .catch(()=>{
            const len=(audioCtx.sampleRate||48000)*1.2; const ir=audioCtx.createBuffer(2,len,audioCtx.sampleRate);
            for(let c=0;c<2;c++){ const d=ir.getChannelData(c); for(let i=0;i<len;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/len,3); } }
            loadedIRBuffer=ir; nodes.convolver.buffer=ir;
          });
      }

      function rebuildGraph(){
        if(!audioCtx || !source) return;
        try{ source.disconnect(); }catch(e){}
        [gain, analyser, filter, nodes.distortion, nodes.post, nodes.distGain, nodes.delay, nodes.feedback, nodes.bit, nodes.glitch, nodes.convolver, nodes.gainDry, nodes.gainWet].forEach(n=>{ if(n){ try{ n.disconnect(); }catch(e){} } });

        let last=source;
        filter.type='bandpass'; filter.frequency.value=+freq.value;
        last.connect(filter); last=filter;

        if(effect.distortion){ nodes.distortion.curve=makeCurve(75); last.connect(nodes.distortion); nodes.distortion.connect(nodes.post); nodes.post.connect(nodes.distGain); last=nodes.distGain; }
        if(effect.echo){ last.connect(nodes.delay); last=nodes.delay; }
        if(effect.crush){ nodes.bit.gain.value=-40; last.connect(nodes.bit); last=nodes.bit; } else { nodes.bit.gain.value=0; }
        if(effect.glitch){ last.connect(nodes.glitch); last=nodes.glitch; }

        gain.gain.value=+vol.value;

        if(effect.reverb && loadedIRBuffer){
          nodes.convolver.buffer=loadedIRBuffer;
          nodes.gainDry.gain.value=1-reverbWet; nodes.gainWet.gain.value=reverbWet;
          last.connect(nodes.gainDry); nodes.gainDry.connect(gain);
          last.connect(nodes.convolver); nodes.convolver.connect(nodes.gainWet); nodes.gainWet.connect(gain);
        }else{
          last.connect(gain);
        }

        gain.connect(analyser);
        analyser.connect(audioCtx.destination);
        analyser.connect(nodes.streamDest);
      }

      function visualize(){
        if(!analyser){ requestAnimationFrame(visualize); return; }
        const data=new Uint8Array(analyser.fftSize);
        ctx.clearRect(0,0,canvas.width,canvas.height);
        analyser.getByteTimeDomainData(data);
        const w=canvas.width, h=canvas.height, step=w/(data.length-1);
        ctx.lineWidth=2; ctx.strokeStyle='#00ff66';
        ctx.beginPath();
        for(let i=0;i<data.length;i++){
          const x=i*step, y=(data[i]/255)*h; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        requestAnimationFrame(visualize);
      }

      file.addEventListener('change', ()=>{
        const f=file.files&&file.files[0]; if(!f) return;
        if(micStream) stopMic();
        fileName.textContent=f.name||'No file chosen';
        originalURL=URL.createObjectURL(f);
        player.src=originalURL; player.load();
        ensureContext();
        f.arrayBuffer().then(buf=>audioCtx.decodeAudioData(buf)).then(decoded=>{
          originalBuffer=decoded;
          if(!playerSource) playerSource=audioCtx.createMediaElementSource(player);
          source=playerSource; rebuildGraph();
          player.playbackRate=+pitch.value; player.muted=false;
        }).catch(()=>{});
      });

      function buildReversedURL(){
        if(!originalBuffer) return null;
        const ch=originalBuffer.numberOfChannels,len=originalBuffer.length,sr=originalBuffer.sampleRate;
        const outBuf=new AudioBuffer({length:len,numberOfChannels:ch,sampleRate:sr});
        for(let c=0;c<ch;c++){ const src=originalBuffer.getChannelData(c), dst=outBuf.getChannelData(c); for(let i=0;i<len;i++){ dst[i]=src[len-1-i]; } }
        const total=len*ch*2; const ab=new ArrayBuffer(44+total); const view=new DataView(ab); let o=0;
        const ws=s=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); o+=s.length; };
        // WAV header
        ws('RIFF'); view.setUint32(o,36+total,true); o+=4; ws('WAVE'); ws('fmt '); view.setUint32(o,16,true); o+=4;
        view.setUint16(o,1,true); o+=2; view.setUint16(o,ch,true); o+=2; view.setUint32(o,sr,true); o+=4; view.setUint32(o,sr*ch*2,true); o+=4; view.setUint16(o,ch*2,true); o+=2; view.setUint16(o,16,true); o+=2;
        ws('data'); view.setUint32(o,total,true); o+=4; const inter=new Int16Array(total/2); let idx=0;
        for(let i=0;i<len;i++){ for(let c=0;c<ch;c++){ let v=outBuf.getChannelData(c)[i]*0x7FFF; v=Math.max(-32768,Math.min(32767,v)); inter[idx++]=v; } }
        for(let j=0;j<inter.length;j++) view.setInt16(44+j*2,inter[j],true);
        return URL.createObjectURL(new Blob([new DataView(ab)],{type:'audio/wav'}));
      }
      function buildReversedBuffer(){
        if(!originalBuffer) return null;
        const ch=originalBuffer.numberOfChannels,len=originalBuffer.length,sr=originalBuffer.sampleRate;
        const out=audioCtx.createBuffer(ch,len,sr);
        for(let c=0;c<ch;c++){ const s=originalBuffer.getChannelData(c), d=out.getChannelData(c); for(let i=0;i<len;i++){ d[i]=s[len-1-i]; } }
        return out;
      }
      reverseBtn.addEventListener('click', ()=>{
        if(!originalBuffer) return alert('Upload audio first');
        if(!reversedURL) reversedURL=buildReversedURL();
        reversed=!reversed; reverseBtn.dataset.active=String(reversed);
        reverseBtn.setAttribute('aria-pressed', String(reversed));
        const wasPlaying=!player.paused; player.pause();
        player.src=reversed?reversedURL:originalURL; player.load();
        if(wasPlaying) player.play();
      });

      effWrap.addEventListener('click', e=>{
        const btn=e.target.closest('button[data-effect]'); if(!btn) return;
        const name=btn.dataset.effect; const state = !(btn.dataset.active==='true');
        btn.dataset.active=String(state);
        btn.setAttribute('aria-pressed', String(state));
        effect[name]=state;
        toggleGlitch(name==='glitch' && effect[name]);
        rebuildGraph();
      });

      function applyPreset(name){
        effect.distortion=false; effect.echo=false; effect.crush=false; effect.glitch=false;
        let f=1200,p=1,v=1;
        if(name==='CHARRED'){ effect.distortion=true; effect.crush=true; f=900; p=.95; v=1; }
        else if(name==='BAKED'){ effect.distortion=true; effect.echo=true; f=1400; p=1.05; v=1; }
        else if(name==='FRIED'){ effect.echo=true; effect.glitch=true; effect.crush=true; f=1100; p=1.0; v=1; }
        [...effWrap.querySelectorAll('button[data-effect]')].forEach(b=>{ const n=b.dataset.effect; b.dataset.active=String(effect[n]); b.setAttribute('aria-pressed', String(effect[n])); });
        freq.value=f; freq.dispatchEvent(new Event('input'));
        pitch.value=p; pitch.dispatchEvent(new Event('input'));
        vol.value=v; vol.dispatchEvent(new Event('input'));
        toggleGlitch(effect.glitch);
        rebuildGraph();
      }
      if(presetsRow) presetsRow.addEventListener('click', e=>{
        const b=e.target.closest('button[data-preset]'); if(!b) return; applyPreset(b.dataset.preset);
      });

      if(reverbPresetSel){
        reverbPresetSel.addEventListener('change', ()=>{
          const key=reverbPresetSel.value; effect.reverb = key!=='off';
          if(effect.reverb){ loadIR(key).then(rebuildGraph); } else { rebuildGraph(); }
        });
      }

      function resetAll(){
        reversed=false; reverseBtn.dataset.active='false'; reverseBtn.setAttribute('aria-pressed','false'); if(originalURL){ player.src=originalURL; player.load(); }
        effect.distortion=false; effect.echo=false; effect.crush=false; effect.glitch=false; effect.reverb=false; toggleGlitch(false);
        if(reverbPresetSel) reverbPresetSel.value='off'; loadedIRBuffer=null;
        [...effWrap.querySelectorAll('button[data-effect]')].forEach(b=>{ b.dataset.active='false'; b.setAttribute('aria-pressed','false'); });
        freq.value=1200; freqOut.textContent='1200Hz'; if(filter) filter.frequency.value=1200;
        pitch.value=1; pitchOut.textContent='1.00×'; player.playbackRate=1;
        vol.value=1; volOut.textContent='1.00'; if(gain) gain.gain.value=1;
        seek.value=0; curT.textContent='0:00'; durT.textContent='0:00';
        rebuildGraph();
      }
      if(resetBtn) resetBtn.addEventListener('click', resetAll);

      freq.addEventListener('input', ()=>{ freqOut.textContent=`${Math.round(freq.value)}Hz`; if(filter) filter.frequency.value=+freq.value; });
      pitch.addEventListener('input', ()=>{ pitchOut.textContent=`${dec2(pitch.value)}×`; player.playbackRate=+pitch.value; });
      vol.addEventListener('input', ()=>{ volOut.textContent=dec2(vol.value); if(gain) gain.gain.value=+vol.value; });

      playBtn.addEventListener('click', ()=>{ if(!player.src && !micStream) return; ensureContext(); if(player.paused){ player.play(); } else { player.pause(); } });
      player.addEventListener('play', ()=>{ playBtn.textContent='⏸'; });
      player.addEventListener('pause', ()=>{ playBtn.textContent='▶'; });
      player.addEventListener('timeupdate', ()=>{ if(!isNaN(player.duration)){ seek.value=Math.floor((player.currentTime/player.duration)*1000)||0; curT.textContent=fmt(player.currentTime); }});
      player.addEventListener('loadedmetadata', ()=>{ durT.textContent=fmt(player.duration); });
      seek.addEventListener('input', ()=>{ if(!isNaN(player.duration)){ player.currentTime=(seek.value/1000)*player.duration; }});

      function startMic(){
        ensureContext();
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ alert('Microphone not supported'); return; }
        navigator.mediaDevices.getUserMedia({audio:true})
          .then(stream=>{ micStream=stream; micSource=audioCtx.createMediaStreamSource(stream); source=micSource; rebuildGraph(); micBtn.dataset.active='true'; micBtn.textContent='🎙️ Mic On'; micBtn.setAttribute('aria-pressed','true'); try{ player.pause(); }catch(e){} })
          .catch(()=>{ alert('Microphone permission denied'); });
      }
      function stopMic(){ if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; } micSource=null; if(playerSource){ source=playerSource; rebuildGraph(); } micBtn.dataset.active='false'; micBtn.textContent='🎙️ Use Mic'; micBtn.setAttribute('aria-pressed','false'); }
      micBtn.addEventListener('click', ()=>{ micStream ? stopMic() : startMic(); });

      /* ---------- WAV EXPORT with ISW Signature (RIFF INFO) ---------- */
      exportBtn.addEventListener('click', ()=>{
        if(!originalBuffer) return alert('Upload audio first');
        ensureContext();
        const srcBuf=reversed?buildReversedBuffer():originalBuffer;
        const ch=srcBuf.numberOfChannels, sr=srcBuf.sampleRate, frames=Math.ceil(srcBuf.length/Math.max(0.0001,+pitch.value));
        const off=new OfflineAudioContext(ch,frames,sr);
        const bs=off.createBufferSource(); bs.buffer=srcBuf; bs.playbackRate.value=+pitch.value;
        const ofilter=off.createBiquadFilter(); ofilter.type='bandpass'; ofilter.frequency.value=+freq.value;
        const ogain=off.createGain(); ogain.gain.value=+vol.value;
        const odist=off.createWaveShaper(); if(effect.distortion){ const n=44100,curve=new Float32Array(n); for(let i=0;i<n;i++){ const x=i*2/n-1; curve[i]=Math.tanh(76*x)/Math.tanh(76); } odist.curve=curve; }
        const opost=off.createBiquadFilter(); opost.type='bandpass'; opost.Q.value=1.5; opost.frequency.value=1000;
        const odg=off.createGain(); odg.gain.value=.4;
        const odelay=off.createDelay(); odelay.delayTime.value=.25; const ofb=off.createGain(); ofb.gain.value=.3; odelay.connect(ofb); ofb.connect(odelay);
        const obit=off.createBiquadFilter(); obit.type='highshelf'; obit.frequency.value=8000; obit.gain.value=effect.crush?-40:0;
        const oglitch=off.createGain(); oglitch.gain.value=1; if(effect.glitch){ let t=0; const step=.03; while(t<(frames/sr)){ oglitch.gain.setValueAtTime(Math.random()>.5?1:0,t); t+=step; } }
        let last=bs; last.connect(ofilter); last=ofilter;
        if(effect.distortion){ last.connect(odist); odist.connect(opost); opost.connect(odg); last=odg; }
        if(effect.echo){ last.connect(odelay); last=odelay; }
        if(effect.crush){ last.connect(obit); last=obit; }
        if(effect.glitch){ last.connect(oglitch); last=oglitch; }
        if(effect.reverb && loadedIRBuffer){
          const oconv=off.createConvolver(); oconv.buffer=loadedIRBuffer;
          const oWet=off.createGain(); oWet.gain.value=reverbWet;
          const oDry=off.createGain(); oDry.gain.value=1-reverbWet;
          last.connect(oDry); oDry.connect(ogain);
          last.connect(oconv); oconv.connect(oWet); oWet.connect(ogain);
        }else{ last.connect(ogain); }
        ogain.connect(off.destination); bs.start();
        off.startRendering()
          .then(rendered=>{
            const ab=bufferToWavWithInfo(rendered,
              'Generated with RADIOFRY // Iron Signal Works — https://ironsignalworks.com');
            const blob=new Blob([new DataView(ab)],{type:'audio/wav'});
            const a=document.createElement('a');
            const stamp = new Date().toISOString().replace(/[:.]/g,'-');
            a.href=URL.createObjectURL(blob);
            a.download=`radiofry_export_isw_${stamp}.wav`;
            a.click();
          })
          .catch(err=>{ console.error(err); alert('Render failed'); });
      });

      function bufferToWavWithInfo(buf, comment){
        const ch=buf.numberOfChannels, sr=buf.sampleRate;
        const samples=buf.length;
        const dataLen=samples*ch*2;

        // Build PCM data
        const pcm = new Int16Array(samples*ch);
        let i=0;
        for(let s=0;s<samples;s++){
          for(let c=0;c<ch;c++){
            let v=buf.getChannelData(c)[s]*0x7FFF;
            v=Math.max(-32768,Math.min(32767,v));
            pcm[i++]=v;
          }
        }

        // Build LIST/INFO (ICMT) chunk
        function pad2(n){ return (n%2) ? n+1 : n; }
        const txt = new TextEncoder().encode(comment + '\0'); // include null terminator per INFO
        const icmtSize = 4 + 4 + pad2(txt.length); // 'ICMT' + size + data (padded)
        const listSize = 4 + 4 + icmtSize; // 'INFO' + subchunks
        const riffSize = 4 + (8+16) + (8+dataLen) + (8+listSize);

        const ab = new ArrayBuffer(8 + riffSize);
        const view = new DataView(ab);
        let o=0;
        const ws=s=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); o+=s.length; };

        // RIFF header
        ws('RIFF'); view.setUint32(o, riffSize, true); o+=4; ws('WAVE');

        // fmt  chunk
        ws('fmt '); view.setUint32(o,16,true); o+=4;
        view.setUint16(o,1,true); o+=2;           // PCM
        view.setUint16(o,ch,true); o+=2;
        view.setUint32(o,sr,true); o+=4;
        view.setUint32(o,sr*ch*2,true); o+=4;     // byte rate
        view.setUint16(o,ch*2,true); o+=2;        // block align
        view.setUint16(o,16,true); o+=2;          // bits per sample

        // data chunk
        ws('data'); view.setUint32(o,dataLen,true); o+=4;
        for(let j=0;j<pcm.length;j++) view.setInt16(o + j*2, pcm[j], true);
        o += dataLen;
        if (dataLen % 2) { view.setUint8(o, 0); o+=1; } // pad

        // LIST INFO chunk with ICMT
        ws('LIST'); view.setUint32(o, listSize, true); o+=4;
        ws('INFO');

        // ICMT subchunk
        ws('ICMT'); view.setUint32(o, txt.length, true); o+=4;
        new Uint8Array(ab, o, txt.length).set(txt); o += pad2(txt.length);

        return ab;
      }

      window.addEventListener('resize', setCanvasSize, {passive:true});
      setCanvasSize(); ensureContext(); requestAnimationFrame(visualize);

      /* Help popup */
      helpBtn.addEventListener('click', ()=> howto.classList.toggle('show'));
      howtoClose.addEventListener('click', ()=> howto.classList.remove('show'));

      /* ---------- Share: copy reloadable URL with UTM ---------- */
      function shareURL(){
        const base = "https://ironsignalworks.com/radiofry";
        const p = new URLSearchParams();
        // capture state
        p.set('sk', skins[skinIndex]);
        p.set('fxd', String(effect.distortion));
        p.set('fxe', String(effect.echo));
        p.set('fxc', String(effect.crush));
        p.set('fxg', String(effect.glitch));
        p.set('rev', String(reverbPresetSel.value||'off'));
        p.set('fq', String(freq.value));
        p.set('pt', String(pitch.value));
        p.set('vl', String(vol.value));
        p.set('rvd', String(reversed));
        // UTM
        p.set('utm_source','radiofry');
        p.set('utm_medium','share');
        p.set('utm_campaign','lab-to-site');
        const url = base + '?' + p.toString();
        navigator.clipboard.writeText(url).then(()=>{
          shareBtn.textContent='Copied!';
          setTimeout(()=> shareBtn.textContent='Share', 1200);
        });
      }
      shareBtn.addEventListener('click', shareURL);

      // Load from params
      (function initFromParams(){
        const p = new URLSearchParams(location.search);
        const sk = p.get('sk'); if(sk){ skinIndex = Math.max(0, ['classic','darkops','office'].indexOf(sk)); applySkin(skins[skinIndex]||'classic'); }
        const parseBool = v => v === 'true';
        effect.distortion = parseBool(p.get('fxd'));
        effect.echo       = parseBool(p.get('fxe'));
        effect.crush      = parseBool(p.get('fxc'));
        effect.glitch     = parseBool(p.get('fxg'));
        const rev = p.get('rev'); if(rev){ reverbPresetSel.value = rev; effect.reverb = rev !== 'off'; if(effect.reverb){ loadIR(rev); } }
        const fq = p.get('fq');  if(fq){ freq.value = +fq; freqOut.textContent = `${Math.round(fq)}Hz`; }
        const pt = p.get('pt');  if(pt){ pitch.value = +pt; pitchOut.textContent = Number(pt).toFixed(2)+'×'; }
        const vl = p.get('vl');  if(vl){ vol.value = +vl; volOut.textContent = Number(vl).toFixed(2); }
        const rvd = p.get('rvd'); if(rvd){ reversed = parseBool(rvd); reverseBtn.dataset.active=String(reversed); reverseBtn.setAttribute('aria-pressed', String(reversed)); }

        // reflect effect buttons
        [...effWrap.querySelectorAll('button[data-effect]')].forEach(b=>{
          const n=b.dataset.effect; b.dataset.active=String(!!effect[n]); b.setAttribute('aria-pressed', String(!!effect[n]));
        });

        rebuildGraph();
      })();
    })();
  </script>
</body>
</html>
